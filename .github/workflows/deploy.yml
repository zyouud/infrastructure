name: deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  NAMESPACE: zyoud
  FRONTEND_IMAGE: ghcr.io/zyouud/apptraining-frontend
  BACKEND_IMAGE: ghcr.io/zyouud/apptraining-backend

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Set image tags (immutable)
        run: |
          echo "TAG=${GITHUB_SHA::7}" >> $GITHUB_ENV

      - name: Build & push backend
        run: |
          docker build -t "$BACKEND_IMAGE:$TAG" ./backend
          docker push "$BACKEND_IMAGE:$TAG"

      - name: Build & push frontend
        run: |
          docker build -t "$FRONTEND_IMAGE:$TAG" ./frontend
          docker push "$FRONTEND_IMAGE:$TAG"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.29.0'

      - name: Debug K3S_SERVER (must not be 127.0.0.1)
        run: |
          echo "K3S_SERVER=${K3S_SERVER}"
          if echo "${K3S_SERVER}" | grep -q "127.0.0.1"; then
            echo "ERROR: K3S_SERVER is 127.0.0.1. Set GitHub Secret K3S_SERVER to your public API server, e.g. https://37.27.31.43:6443"
            exit 1
          fi
        env:
          K3S_SERVER: ${{ secrets.K3S_SERVER }}

      - name: Configure kubeconfig (k3s) - robust (NO SSH)
        shell: bash
        run: |
          set -euo pipefail

          # Fail fast if secrets are empty
          : "${K3S_SERVER:?K3S_SERVER is empty}"
          : "${K3S_TOKEN:?K3S_TOKEN is empty}"
          : "${K3S_CA_CRT:?K3S_CA_CRT is empty}"

          mkdir -p ~/.kube

          # Create kubeconfig via kubectl commands (avoids YAML indentation issues)
          kubectl config set-cluster k3s \
            --server="${K3S_SERVER}" \
            --certificate-authority=/tmp/ca.crt \
            --embed-certs=true

          echo "${K3S_CA_CRT}" | base64 -d > /tmp/ca.crt

          kubectl config set-credentials zyoud-gha --token="${K3S_TOKEN}"

          kubectl config set-context zyoud \
            --cluster=k3s \
            --user=zyoud-gha \
            --namespace="${NAMESPACE}"

          kubectl config use-context zyoud

          # Connectivity checks (non-interactive)
          kubectl version --short
          kubectl get ns
          kubectl -n "${NAMESPACE}" get pods
        env:
          K3S_SERVER: ${{ secrets.K3S_SERVER }}
          K3S_TOKEN: ${{ secrets.K3S_TOKEN }}
          K3S_CA_CRT: ${{ secrets.K3S_CA_CRT }}

      - name: Apply Kubernetes manifests (from repo)
        run: |
          kubectl apply -f k8s/cert-manager/
          kubectl apply -f k8s/vault/
          kubectl apply -f k8s/postgres/
          kubectl apply -f k8s/backend/
          kubectl apply -f k8s/frontend/
          kubectl apply -f k8s/ingress/

      - name: Update images on Deployments (no latest, no forced restart)
        run: |
          kubectl -n ${NAMESPACE} set image deployment/zyoud-backend backend=${BACKEND_IMAGE}:${TAG}
          kubectl -n ${NAMESPACE} set image deployment/zyoud-frontend frontend=${FRONTEND_IMAGE}:${TAG}

      - name: Rollout status
        run: |
          kubectl -n ${NAMESPACE} rollout status deploy/zyoud-backend --timeout=180s
          kubectl -n ${NAMESPACE} rollout status deploy/zyoud-frontend --timeout=180s
